{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/auth/[...nextauth]/auth.ts"],"sourcesContent":["import { PrismaAdapter } from \"@next-auth/prisma-adapter\";\nimport { PrismaClient } from \"@prisma/client\";\nimport { NextAuthOptions } from \"next-auth\";\nimport { type User } from \"next-auth\";\nimport GoogleProvider from \"next-auth/providers/google\";\n\nconst prisma = new PrismaClient();\n\nexport const authOptions: NextAuthOptions = {\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_CLIENT_ID!,\n      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n      authorization: { params: { access_type: \"offline\", prompt: \"consent\" } },\n    }),\n  ],\n  callbacks: {\n    async jwt({ token, account }) {\n      console.log(\"jwt works\");\n      if (account) {\n        console.log(\"ACCOUNT! WE HAVE AN ACCOUNT BLESSED LORD WE DO\");\n        // First login, save the `access_token`, `refresh_token`, and other\n        // details into the JWT\n\n        const userProfile: User = {\n          // @ts-ignore\n          id: token.sub,\n          // @ts-ignore\n          name: profile?.name,\n          // @ts-ignore\n          email: profile?.email,\n          image: token?.picture,\n        };\n\n        return {\n          access_token: account.access_token,\n          expires_at: account.expires_at,\n          refresh_token: account.refresh_token,\n          user: userProfile,\n        };\n      } else if (Date.now() < token.expires_at * 1000) {\n        // Subsequent logins, if the `access_token` is still valid, return the JWT\n        return token;\n      } else {\n        // Subsequent logins, if the `access_token` has expired, try to refresh it\n        if (!token.refresh_token) throw new Error(\"Missing refresh token\");\n\n        try {\n          // The `token_endpoint` can be found in the provider's documentation. Or if they support OIDC,\n          // at their `/.well-known/openid-configuration` endpoint.\n          // i.e. https://accounts.google.com/.well-known/openid-configuration\n          const response = await fetch(\"https://oauth2.googleapis.com/token\", {\n            headers: { \"Content-Type\": \"application/x-www-form-urlencoded\" },\n            body: new URLSearchParams({\n              client_id: process.env.AUTH_GOOGLE_ID!,\n              client_secret: process.env.AUTH_GOOGLE_SECRET!,\n              grant_type: \"refresh_token\",\n              refresh_token: token.refresh_token!,\n            }),\n            method: \"POST\",\n          });\n\n          const responseTokens = await response.json();\n\n          if (!response.ok) throw responseTokens;\n\n          return {\n            // Keep the previous token properties\n            ...token,\n            access_token: responseTokens.access_token,\n            expires_at: Math.floor(\n              Date.now() / 1000 + (responseTokens.expires_in as number)\n            ),\n            // Fall back to old refresh token, but note that\n            // many providers may only allow using a refresh token once.\n            refresh_token: responseTokens.refresh_token ?? token.refresh_token,\n          };\n        } catch (error) {\n          console.error(\"Error refreshing access token\", error);\n          // The error property can be used client-side to handle the refresh token error\n          return { ...token, error: \"RefreshAccessTokenError\" as const };\n        }\n      }\n    },\n    async session({ session, token }) {\n      if (token?.user && session) {\n        // @ts-ignore\n        session.user = token.user as User;\n      }\n\n      return session;\n    },\n  },\n  useSecureCookies: false,\n  adapter: PrismaAdapter(prisma),\n};\n\ndeclare module \"next-auth\" {\n  interface Session {\n    error?: \"RefreshAccessTokenError\";\n  }\n}\n\ndeclare module \"next-auth/jwt\" {\n  interface JWT {\n    access_token: string;\n    expires_at: number;\n    refresh_token: string;\n    error?: \"RefreshAccessTokenError\";\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAMA,MAAM,SAAS,IAAI,uDAAA,CAAA,eAAY;AAExB,MAAM,cAA+B;IAC1C,WAAW;QACT,CAAA,GAAA,qJAAA,CAAA,UAAc,AAAD,EAAE;YACb,UAAU,QAAQ,GAAG,CAAC,gBAAgB;YACtC,cAAc,QAAQ,GAAG,CAAC,oBAAoB;YAC9C,eAAe;gBAAE,QAAQ;oBAAE,aAAa;oBAAW,QAAQ;gBAAU;YAAE;QACzE;KACD;IACD,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,OAAO,EAAE;YAC1B,QAAQ,GAAG,CAAC;YACZ,IAAI,SAAS;gBACX,QAAQ,GAAG,CAAC;gBACZ,mEAAmE;gBACnE,uBAAuB;gBAEvB,MAAM,cAAoB;oBACxB,aAAa;oBACb,IAAI,MAAM,GAAG;oBACb,aAAa;oBACb,MAAM,SAAS;oBACf,aAAa;oBACb,OAAO,SAAS;oBAChB,OAAO,OAAO;gBAChB;gBAEA,OAAO;oBACL,cAAc,QAAQ,YAAY;oBAClC,YAAY,QAAQ,UAAU;oBAC9B,eAAe,QAAQ,aAAa;oBACpC,MAAM;gBACR;YACF,OAAO,IAAI,KAAK,GAAG,KAAK,MAAM,UAAU,GAAG,MAAM;gBAC/C,0EAA0E;gBAC1E,OAAO;YACT,OAAO;gBACL,0EAA0E;gBAC1E,IAAI,CAAC,MAAM,aAAa,EAAE,MAAM,IAAI,MAAM;gBAE1C,IAAI;oBACF,8FAA8F;oBAC9F,yDAAyD;oBACzD,oEAAoE;oBACpE,MAAM,WAAW,MAAM,MAAM,uCAAuC;wBAClE,SAAS;4BAAE,gBAAgB;wBAAoC;wBAC/D,MAAM,IAAI,gBAAgB;4BACxB,WAAW,QAAQ,GAAG,CAAC,cAAc;4BACrC,eAAe,QAAQ,GAAG,CAAC,kBAAkB;4BAC7C,YAAY;4BACZ,eAAe,MAAM,aAAa;wBACpC;wBACA,QAAQ;oBACV;oBAEA,MAAM,iBAAiB,MAAM,SAAS,IAAI;oBAE1C,IAAI,CAAC,SAAS,EAAE,EAAE,MAAM;oBAExB,OAAO;wBACL,qCAAqC;wBACrC,GAAG,KAAK;wBACR,cAAc,eAAe,YAAY;wBACzC,YAAY,KAAK,KAAK,CACpB,KAAK,GAAG,KAAK,OAAQ,eAAe,UAAU;wBAEhD,gDAAgD;wBAChD,4DAA4D;wBAC5D,eAAe,eAAe,aAAa,IAAI,MAAM,aAAa;oBACpE;gBACF,EAAE,OAAO,OAAO;oBACd,QAAQ,KAAK,CAAC,iCAAiC;oBAC/C,+EAA+E;oBAC/E,OAAO;wBAAE,GAAG,KAAK;wBAAE,OAAO;oBAAmC;gBAC/D;YACF;QACF;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,OAAO,QAAQ,SAAS;gBAC1B,aAAa;gBACb,QAAQ,IAAI,GAAG,MAAM,IAAI;YAC3B;YAEA,OAAO;QACT;IACF;IACA,kBAAkB;IAClB,SAAS,CAAA,GAAA,sKAAA,CAAA,gBAAa,AAAD,EAAE;AACzB"}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/src/app/api/auth/[...nextauth]/route.ts"],"sourcesContent":["import NextAuth from \"next-auth/next\";\nimport { authOptions } from \"./auth\";\n\nconst handler = NextAuth(authOptions);\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;;;;;;AAGA,MAAM,UAAU,CAAA,GAAA,+IAAA,CAAA,UAAQ,AAAD,EAAE,yJAAA,CAAA,cAAW"}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}